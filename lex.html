<!doctype html>
<html>
<head>
    <title>Lex</title>
     <style type="text/css">
<!--

body {
    margin-top: 20mm;
    margin-right: 18mm;
    margin-bottom: 20mm;
    margin-left: 18mm;
    border-width: 0;
    padding-top: 0px;
    padding-right: 0px;
    padding-bottom: 0px;
    padding-left: 0px;
    margin: 0;
    vertical-align: baseline;
    font-size:16px;
}

table {
     vertical-align: baseline;
}
.paragraf {
    text-indent: 10pt;
}

.IndentedBlock3ex {
    margin-left: 3ex;
}

.IndentedBlock2ex {
    margin-left: 2ex;
}

.IndentedBlock1ex {
    margin-left: 1ex;
}
.NovaStranica {
    page-break-before: auto;
    page-break-after: always;
}

.NaslovStranice
{
 font-size:30px;
 font-weight:bold;
}

.NaslovGlavni
{
 font-size:28px;
 font-weight:bold;
}

.NaslovPod
 {
  font-size: 22px;
  font-weight:bold;
 }

.Naslovcic
 {
  font-size: 18px;
  font-weight:bold;
 }

.NaslovcicJosManji
 {
  font-size: 16px;
  font-weight:bold;
 }

.TextObican
 {
    font-size: 15px;
 }
.TOCItem
{
 font-size:18px;
 font-weight:bold;
}


.NaslovDefinicije
{
    font-size: 10;
}

.TextCode
 {
    font-size: 12px;
 }

-->
  </style>
</head>
<body>

		<h1 align="center" > <div class="NaslovStranice">LEX</div> </h1>
		<table border="0" width="100%">
			<tr>
				<td width="100%">&nbsp;</td>
				<td nowrap="nowrap">
					Document number: <br>
					Date: <br>
					Reply to:<br>
					<br>
				</td>
				<td nowrap="nowrap">
					<br>
					2019/09/10<br>
					Dejan D.M. Milosavljevic<br>
					(dmilos at gmail dot com)<br>
				</td>
				<td width="10%">&nbsp;</td>
			</tr>
		</table>
		<dl>
			<dt><div class="NaslovGlavni">Table of Contents.</div></dt>
			<dd>
				<ul>
					<li><div class="TOCItem">I. Introduction</div></li>
					<li><div class="TOCItem">II. Motivation and Scope</div></li>
					<li><div class="TOCItem">III. Solutions</div></li>
					<li><div class="TOCItem">IV. Design Decisions</div></li>
					<li><div class="TOCItem">V. Impact On the Standard</div></li>
					<li><div class="TOCItem">VI. References</div></li>
				</ul>
			</dd>

			<dt><div class="NaslovGlavni">I. Introduction</div></dt>
			<dd>
				Lex it self offer better handling and manipulation of regular expressions when stream parsing is needed.
                In here will be presented one possible implementation of lex.
			</dd>
			<dt><div class="NaslovGlavni">II. Motivation and Scope</div></dt>
			<dd>
			There is a trend to add more features to existing regular expression.<br>
			Main reason for this i that regular expression can ( and must ) be implemented only by using finite state machines.<br>
			And there should be guarantee that implementation use finite state machines.<br>
			With this it is possible to guarantee time and complexity of regex execution( if not ).<br>
			See: Chomsky_hierarchy.

			</DD>
			<dt><div class="NaslovGlavni">III. Solutions</div></dt>
			<dd>
				Add lex.<br>

<pre>
    Code sample:
    typedef  std::lex&lt;int &gt; lex_t;
    lex_t l;

    l.token( std::regex("[0-9]+"), []( lex_t::match_type const& mt )->void{ std::cout << "number"; });
    l.token( std::regex("\n"),     []( lex_t::match_type const& mt )->void{ std::cout << "new-line"; });
    l.token( std::regex(","),      []( lex_t::match_type const& mt )->void{ std::cout << "separator"; });
    l.compile();

    //Simpliest variant. Condition: [lambda-have:(true)]
    std::ifstream ifs("test2.txt")
    l.eat( std::istream_iterator<char>( ifs ), std::istream_iterator<char>() );
    // No need for reset or flush. everything is automatic inside eat( begin, end )
    
    //Feed lex one by one character. Condition: [lambda-have:(true)]
    std::ifstream ifs("test1.txt")
    while( ifs.eof() )
    {
        l.eat( ifs.get() );
    }
    l.flush(); // No more input. Call appropriate lambda if unique exists. Clear internal state. 

    // [lambda-have:(false)] Most complicated variant, Probably the fastest comparing to [lambda-have:(true)]
    do
    {
        if( true == ifs.eof() )
            l.flush();
        else
            if( false == l.eat( ifs.get() ) )
                break;

        lex_t::size_type  t = l.token();
        if( l.size() == l.token() )
            switch( l.token() )
            {
                case( 0 ): std::cout << "number";    break;
                case( 1 ): std::cout << "new-line";  break;
                case( 2 ): std::cout << "separator"; break;
            }
    }while( false == ifs.eof() )


</pre>

<pre>


    template< typename character_name >
      class lex //[name:lex|flex|Lex]
       {
        typedef character_name char_type;
        typedef std::size_t size_type;

        typedef std::regex<character_name> regex_type;
        typedef --TODO-- match_type;
        typedef std::function< void( match_type const&) > action_type; //!< [lambda-have:(true)]
        typedef --implementation-defined-- iterator_type;

        // Container things
        void clear(); //! Clear everything including parse state, good will return false, size() will return 0.
        size_type size()const;
        iterator_type begin();
        iterator_const cbegin()const;
        iterator_type end();
        iterator_const cend()const;

        void erase( iterator_type );

        size_type push( regex_type ); //!< [lambda-have:(false)]//!< return value is allways equal to prevously retrieved size()
        size_type push( regex_type, action_type ); //!< [push-lambda-return:bool|size_t] [lambda-have:(true)] //!< return value is allways equal to prevously retrieved size().

        // the logic.
        bool compile();

        bool eat( char_type ); //! processing one character. true - Parsing is OK, waiting for another. false - can not process given character. 
        template< typename iterator_name >
         iterator_name eat( iterator_name const& begin iterator_name const& end ); //! processing sequence, return last unprocessed or equal to end.
        void flush(); No more input. Finish parsing. Also clear internal state, same as restart

        // eqial to size() - waiting for more character.
        // not equal to size() - have complete token, last eaten character is not part of parsed token
        size_type token(); //[lambda-have:(false)],

        bool good()const; //! No push/remove performed after compile
        bool restart(); //! clear internal parse state
       };

</pre>

			</dd>
			<dt><div class="NaslovGlavni">IV. Summary of options</div></dt>
			<dd>
				<dl>
					<dt>name.</dt><dd>TODO.</dd>
					<dt>lambda-have.</dt><dd>TODO.</dd>
				</dl>
			</dd>


			</dd>
			<dt><div class="NaslovGlavni">IV. Design Decisions</div></dt>
			<dd>
				<ul>
					<li>TODO.</li>
				</ul>
			</dd>

			<dt><div class="NaslovGlavni">V. Impact On the Standard</div></dt>
			<dd>
				<dl>
					<dt> <div class="NaslovPod ">Core</div> </dt>
					<dd>
						None. This is library level.
					</dd>
					<dt><div class="NaslovPod ">Library</div></dt>
					<dd>None. This is new feature.</dd>
					<dt><div class="NaslovPod ">Existing code.</div></dt>
					<dd>None. New class will be under std namespace.</dd>
				</dl>
			</dd>


			<dt><div class="NaslovGlavni">VI. Links</div></dt>
			<dd>
				<dl>
					<dt> <div class="NaslovPod ">Core</div> </dt>
					<dd>

            2 . Chomsky_hierarchy
            - https://en.wikipedia.org/wiki/Chomsky_hierarchy
            3. A bit of history
            - https://en.wikipedia.org/wiki/Lex_%28software%29

					</dd>
				</dl>
			</dd>


		</dl>
		<hr shade width="100%" align="center">

</body>
</html>
